<!doctype html>
<html lang="he" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BodyPlus XPro â€” Capture</title>
  <style>
    :root { --bg:#0f172a; --panel:#111827; --muted:#94a3b8; --ok:#22c55e; --warn:#f59e0b; --err:#ef4444; }
    * { box-sizing: border-box; }
    body { margin:0; font-family:system-ui,Segoe UI,Roboto,Arial; background:var(--bg); color:#e5e7eb; line-height:1.45; }
    header { padding:14px 18px; border-bottom:1px solid #1f2937; background:#0b1221; position:sticky; top:0; z-index:1; }
    header h1 { margin:0; font-size:18px; letter-spacing:.3px; }
    main { padding:18px; display:grid; gap:18px; grid-template-columns: 1.2fr .8fr; }
    @media (max-width: 1000px) { main{ grid-template-columns: 1fr; } }
    section, .card { background:var(--panel); border:1px solid #1f2937; border-radius:14px; }
    .card { padding:14px; }
    .row { display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
    label { font-size:12px; color:var(--muted); margin-inline-start:2px; }
    select, input[type="number"], input[type="text"] {
      background:#0b1221; color:#e5e7eb; border:1px solid #273143; border-radius:10px; padding:8px 10px; min-width:80px;
    }
    input[type="checkbox"] { transform:scale(1.15); margin-inline-start:4px; }
    button {
      background:#1f6feb; color:white; border:0; border-radius:10px; padding:9px 14px; cursor:pointer;
      transition:filter .15s ease; font-weight:600;
    }
    button.secondary { background:#334155; }
    button:disabled { opacity:.6; cursor:not-allowed; }
    button:hover:not(:disabled) { filter:brightness(1.08); }

    .grid { display:grid; grid-template-columns: 1fr 1fr; gap:14px; }
    .metrics { display:grid; gap:10px; grid-template-columns: repeat(auto-fit,minmax(130px,1fr)); }
    .metric { background:#0b1221; border:1px solid #263142; border-radius:12px; padding:10px; }
    .metric .v { font-size:18px; font-weight:700; }
    .metric .k { font-size:12px; color:var(--muted); }

    .status { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .dot { width:10px; height:10px; border-radius:50%; background:#64748b; display:inline-block; }
    .dot.ok { background:var(--ok); } .dot.warn{ background:var(--warn);} .dot.err{ background:var(--err);}

    .preview-wrap { position:relative; overflow:hidden; border-bottom-left-radius:14px; border-bottom-right-radius:14px; }
    video, canvas { width:100%; max-height:70vh; background:#000; display:block; }
    .hud {
      position:absolute; top:10px; left:10px; background:rgba(0,0,0,.45); padding:8px 10px; border-radius:10px;
      font-size:12px; color:#e5e7eb; border:1px solid rgba(255,255,255,.08);
    }
    .errbox { background:rgba(239,68,68,.08); border:1px solid rgba(239,68,68,.35); color:#fecaca; padding:10px; border-radius:10px; }
    .hint { color:#94a3b8; font-size:12px; }
    code { background:#0b1221; padding:.15rem .35rem; border-radius:6px; border:1px solid #263142; }

    /* ×›×•×ª×¨×•×ª × ×•×©××™×•×ª */
    .topic-title { font-weight:700; font-size:14px; margin-bottom:8px; color:#e5e7eb; }
    details.topic { background:#0b1221; border:1px solid #273143; border-radius:12px; padding:10px 12px; }
    details.topic + details.topic { margin-top:10px; }
    details.topic summary { cursor:pointer; list-style:none; outline:none; display:flex; align-items:center; gap:8px; }
    details.topic summary::-webkit-details-marker { display:none; }
    .topic-body { margin-top:10px; display:grid; gap:10px; grid-template-columns: repeat(auto-fit,minmax(180px,1fr)); }
    .topic-actions { display:flex; gap:10px; flex-wrap:wrap; }
  </style>
</head>
<body>
  <header>
    <h1>ğŸ¥ BodyPlus XPro â€” ×©×™×“×•×¨ ××¦×œ××” ×œ×“×©×‘×•×¨×“ (ingest)</h1>
  </header>

  <main>
    <!-- ×©×××œ: ×¤×¨×™×•×•×™×• + ×‘×§×¨×” × ×•×©××™×ª -->
    <section>
      <!-- ×‘×§×¨×•×ª ××¡×•×“×¨×•×ª ×œ×¤×™ × ×•×©××™× -->
      <div class="card" style="border-bottom-left-radius:0;border-bottom-right-radius:0;">
        <!-- × ×•×©×: ××§×•×¨ ××¦×œ××” -->
        <details class="topic" open>
          <summary class="topic-title">ğŸ“· ××§×•×¨ ××¦×œ××”</summary>
          <div class="topic-body">
            <div>
              <label for="cameraSelect">××¦×œ××”</label><br />
              <select id="cameraSelect"></select>
            </div>
            <div>
              <label for="resSelect">×¨×–×•×œ×•×¦×™×”</label><br />
              <select id="resSelect">
                <option value="640x360">640Ã—360</option>
                <option value="1280x720" selected>1280Ã—720</option>
                <option value="1920x1080">1920Ã—1080</option>
              </select>
            </div>
            <div class="row">
              <input id="mirror" type="checkbox" checked />
              <label for="mirror">××¨××” (Mirror)</label>
            </div>
          </div>
        </details>

        <!-- × ×•×©×: ×©×™×“×•×¨ ×•××™×›×•×ª -->
        <details class="topic" open>
          <summary class="topic-title">ğŸ“¡ ×©×™×“×•×¨ ×•××™×›×•×ª</summary>
          <div class="topic-body">
            <div>
              <label for="fpsInput">FPS ×©×™×“×•×¨</label><br />
              <input id="fpsInput" type="number" min="1" max="60" value="15" />
            </div>
            <div>
              <label for="jpgQ">××™×›×•×ª JPEG</label><br />
              <input id="jpgQ" type="number" min="40" max="95" value="80" />
            </div>
            <div class="row">
              <input id="hudToggle" type="checkbox" checked />
              <label for="hudToggle">HUD ×‘×¤×¨×™×•×•×™×•</label>
            </div>
          </div>
        </details>

        <!-- × ×•×©×: ××‘×˜×—×” / ×˜×•×§×Ÿ -->
        <details class="topic">
          <summary class="topic-title">ğŸ” ××‘×˜×—×” / ×˜×•×§×Ÿ</summary>
          <div class="topic-body" style="grid-template-columns:minmax(220px,1fr)">
            <div>
              <label for="token">Token (××•×¤×¦×™×•× ×œ×™)</label><br />
              <input id="token" type="text" placeholder="X-Ingest-Token" style="min-width:220px" />
            </div>
          </div>
        </details>

        <!-- × ×•×©×: ×¤×¢×•×œ×•×ª -->
        <details class="topic" open>
          <summary class="topic-title">â–¶ï¸ ×¤×¢×•×œ×•×ª</summary>
          <div class="topic-actions">
            <button id="startBtn">×”×ª×—×œ ×©×™×“×•×¨</button>
            <button id="stopBtn" class="secondary" disabled>×¢×¦×•×¨</button>
          </div>
        </details>
      </div>

      <!-- ×¤×¨×™×•×•×™×• -->
      <div class="preview-wrap">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="canvas" style="display:none"></canvas>
        <div class="hud" id="hudBox" hidden>
          <div><b>××¦×‘:</b> <span id="state">IDLE</span></div>
          <div><b>Tx FPS:</b> <span id="txFps">0.0</span></div>
          <div><b>Latency:</b> <span id="latMs">â€“</span> ms</div>
          <div><b>Frame:</b> <span id="frameSize">â€“</span></div>
        </div>
      </div>

      <!-- ×”×•×“×¢×•×ª ×•×˜×™×¤×™× -->
      <div class="card" style="border-top-left-radius:0;border-top-right-radius:0;">
        <div id="err" class="errbox" style="display:none"></div>
        <div class="hint">
          ×˜×™×¤: ×¤×ª×—/×™ ×‘×˜××‘ × ×•×¡×£ ××ª <code>/video/stream.mjpg?hud=1</code> ×›×“×™ ×œ×¨××•×ª ××ª ×”×–×¨×™××” ×©××ª×¤×¨×¡××ª ×œ×©×¨×ª.
        </div>
      </div>
    </section>

    <!-- ×™××™×Ÿ: ×¡×˜×˜×•×¡, ××“×“×™×, ×§×™×¦×•×¨×™× -->
    <section class="card">
      <!-- × ×•×©×: ×¡×˜×˜×•×¡ -->
      <div class="status" aria-live="polite">
        <span class="dot" id="dot"></span>
        <span id="statusText">×××ª×™×Ÿ ×œ×”×ª×—×œ×”â€¦</span>
      </div>

      <!-- × ×•×©×: ××“×“×™× -->
      <div style="margin-top:14px" class="topic-title">ğŸ“Š ××“×“×™×</div>
      <div class="metrics">
        <div class="metric">
          <div class="v" id="m_tx">0.0</div>
          <div class="k">Tx FPS (× ×©×œ×—)</div>
        </div>
        <div class="metric">
          <div class="v" id="m_lat">â€“</div>
          <div class="k">Latency (ms)</div>
        </div>
        <div class="metric">
          <div class="v" id="m_res">â€“</div>
          <div class="k">×¨×–×•×œ×•×¦×™×”</div>
        </div>
        <div class="metric">
          <div class="v" id="m_sent">0</div>
          <div class="k">×¤×¨×™×™××™× ×©× ×©×œ×—×•</div>
        </div>
      </div>

      <hr style="border:0;border-top:1px solid #273143;margin:16px 0" />

      <!-- × ×•×©×: ×§×™×¦×•×¨×™ ×“×¨×š -->
      <div class="card" style="background:#0b1221">
        <div class="topic-title">ğŸ”— ×§×™×¦×•×¨×™ ×“×¨×š</div>
        <div style="display:grid; gap:8px;">
          <a href="/video/stream.mjpg?hud=1" target="_blank">×¤×ª×— ×¡×˜×¨×™× /video/stream.mjpg?hud=1</a>
          <a href="/api/video/status" target="_blank">×¡×˜×˜×•×¡ ×•×™×“××• (JSON)</a>
          <a href="/version" target="_blank">/version</a>
          <a href="/healthz" target="_blank">/healthz</a>
        </div>
      </div>
    </section>
  </main>

  <script>
  (() => {
    const el = (id) => document.getElementById(id);

    const video = el('video');
    const canvas = el('canvas');
    const hudBox = el('hudBox');
    const stateEl = el('state');
    const txFpsEl = el('txFps');
    const latEl = el('latMs');
    const fsizeEl = el('frameSize');
    const dot = el('dot');
    const statusText = el('statusText');

    const m_tx = el('m_tx');
    const m_lat = el('m_lat');
    const m_res = el('m_res');
    const m_sent = el('m_sent');

    const cameraSelect = el('cameraSelect');
    const resSelect    = el('resSelect');
    const fpsInput     = el('fpsInput');
    const jpgQ         = el('jpgQ');
    const mirror       = el('mirror');
    const hudToggle    = el('hudToggle');
    const tokenInp     = el('token');

    const startBtn = el('startBtn');
    const stopBtn  = el('stopBtn');
    const errBox   = el('err');

    let stream = null;
    let sending = false;
    let lastSent = 0;
    let sentCount = 0;
    let txTimes = [];

    function setDot(mode) {
      dot.classList.remove('ok','warn','err');
      if (mode) dot.classList.add(mode);
    }
    function setError(msg) {
      if (!msg) { errBox.style.display='none'; errBox.textContent=''; return; }
      errBox.style.display='block';
      errBox.textContent = msg;
    }
    function setState(s) { stateEl.textContent = s; statusText.textContent = s; }
    function setHudVisible(v) { hudBox.hidden = !v; }

    async function listCameras() {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const cams = devices.filter(d => d.kind === 'videoinput');
      cameraSelect.innerHTML = '';
      cams.forEach((d, i) => {
        const o = document.createElement('option');
        o.value = d.deviceId;
        o.textContent = d.label || `××¦×œ××” ${i+1}`;
        cameraSelect.appendChild(o);
      });
      const back = cams.find(d => /back|rear/i.test(d.label));
      if (back) cameraSelect.value = back.deviceId;
    }

    function parseRes(val) {
      const [w,h] = (val||'1280x720').split('x').map(v => parseInt(v,10));
      return {width:w||1280, height:h||720};
    }

    async function openCamera() {
      const {width, height} = parseRes(resSelect.value);
      const deviceId = cameraSelect.value || undefined;
      const constraints = {
        audio:false,
        video: {
          width: { ideal: width }, height: { ideal: height },
          frameRate: { ideal: 30, max: 60 },
          ...(deviceId ? { deviceId: { exact: deviceId } } : {}),
          facingMode: deviceId ? undefined : { ideal: "environment" }
        }
      };
      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }
      try {
        setError('');
        const s = await navigator.mediaDevices.getUserMedia(constraints);
        stream = s;
        video.srcObject = s;
        await video.play();
        const vw = video.videoWidth, vh = video.videoHeight;
        canvas.width = vw; canvas.height = vh;
        fsizeEl.textContent = `${vw}Ã—${vh}`;
        m_res.textContent = `${vw}Ã—${vh}`;
      } catch (e) {
        console.error(e);
        setError('×œ× × ×™×ª×Ÿ ×œ×¤×ª×•×— ××¦×œ××”. ×•×“× ×©×”×“×£ ×¢×œ HTTPS ×•×©×™×© ×”×¨×©××•×ª ××¦×œ××”.');
        throw e;
      }
    }

    function drawToCanvas() {
      const ctx = canvas.getContext('2d');
      const vw = video.videoWidth || canvas.width;
      const vh = video.videoHeight || canvas.height;
      canvas.width = vw; canvas.height = vh;
      ctx.save();
      if (mirror.checked) {
        ctx.scale(-1, 1);
        ctx.drawImage(video, -vw, 0, vw, vh);
      } else {
        ctx.drawImage(video, 0, 0, vw, vh);
      }
      ctx.restore();
    }

    function updateTxFps() {
      const now = performance.now();
      txTimes.push(now);
      while (txTimes.length && (now - txTimes[0]) > 2000) txTimes.shift();
      const fps = txTimes.length >= 2 ? (txTimes.length-1) / ((txTimes[txTimes.length-1]-txTimes[0])/1000) : 0;
      txFpsEl.textContent = fps.toFixed(1);
      m_tx.textContent = fps.toFixed(1);
    }

    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    async function sendLoop() {
      const endpoint = '/api/ingest_frame';
      const targetFps = Math.max(1, Math.min(60, parseInt(fpsInput.value||'15',10)));
      const frameInterval = 1000 / targetFps;
      const quality = Math.max(40, Math.min(95, parseInt(jpgQ.value||'80',10))) / 100;

      setState(`SENDING @ ${targetFps} FPS`);
      setDot('ok');
      setHudVisible(hudToggle.checked);

      while (sending) {
        const tStart = performance.now();

        try {
          drawToCanvas();
          const blob = await new Promise(res => canvas.toBlob(res, 'image/jpeg', quality));
          const ab = await blob.arrayBuffer();

          const headers = { 'Content-Type': 'image/jpeg' };
          const tok = tokenInp.value.trim();
          if (tok) headers['X-Ingest-Token'] = tok;

          const r = await fetch(endpoint, {
            method: 'POST',
            headers,
            body: ab,
            keepalive: true,
          });

          if (!r.ok) {
            let msg = `${r.status} ${r.statusText}`;
            try { const j = await r.json(); if (j && j.error) msg += ` | ${j.error}` } catch (_) {}
            throw new Error(msg);
          }

          const j = await r.json();
          const serverTs = j.ts_ms || 0;
          const nowMs = Date.now();
          if (serverTs) {
            const lat = Math.max(0, nowMs - serverTs);
            latEl.textContent = lat;
            m_lat.textContent = lat;
          } else {
            latEl.textContent = 'â€“';
            m_lat.textContent = 'â€“';
          }

          sentCount += 1;
          m_sent.textContent = String(sentCount);
          updateTxFps();
          setError('');

        } catch (e) {
          console.error('send error', e);
          setError('×©×œ×™×—×ª ×¤×¨×™×™× × ×›×©×œ×”: ' + (e?.message || e));
          setDot('warn');
          await sleep(200);
        }

        const elapsed = performance.now() - tStart;
        const wait = Math.max(0, frameInterval - elapsed);
        if (wait > 0) await sleep(wait);
      }

      setState('IDLE');
      setHudVisible(false);
      setDot('');
    }

    async function start() {
      try {
        await openCamera();
        sending = true;
        sentCount = 0;
        txTimes = [];
        startBtn.disabled = true;
        stopBtn.disabled = false;
        await sendLoop();
      } catch (_e) {
        sending = false;
        startBtn.disabled = false;
        stopBtn.disabled = true;
      }
    }

    function stop() {
      sending = false;
      stopBtn.disabled = true;
      startBtn.disabled = false;
      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }
    }

    // ××™×¨×•×¢×™×
    startBtn.addEventListener('click', start);
    stopBtn.addEventListener('click', stop);
    hudToggle.addEventListener('change', () => setHudVisible(hudToggle.checked));
    resSelect.addEventListener('change', async () => { if (sending) await openCamera(); });
    cameraSelect.addEventListener('change', async () => { if (sending) await openCamera(); });

    // ××ª×—×•×œ
    (async () => {
      try { await navigator.mediaDevices.getUserMedia({video:true, audio:false}); } catch (_) {}
      try { await listCameras(); } catch(e){ console.warn(e); }
      setState('IDLE');
      setHudVisible(false);
    })();

    // × ×™×§×•×™
    window.addEventListener('beforeunload', () => {
      sending = false;
      if (stream) stream.getTracks().forEach(t => t.stop());
    });
  })();
  </script>
</body>
</html>
